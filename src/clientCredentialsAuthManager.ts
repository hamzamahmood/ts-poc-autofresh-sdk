/**
 * MdNotesCCGLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { OAuthConfiguration } from './authentication';
import { OAuthToken } from './models/oAuthToken';
import { ClientInterface } from "./clientInterface";
import { OAuthAuthorizationController} from './controllers/oAuthAuthorizationController';
import { OAuthScopeEnum } from './models/oAuthScopeEnum';

export class ClientCredentialsAuthManager {
  private _oAuthClientId: string;
  private _oAuthClientSecret: string;
  private _oAuthScopes?: OAuthScopeEnum[];
  private _oAuthConfiguration?: OAuthConfiguration;
  private _oAuthController: OAuthAuthorizationController;

  constructor({
    oAuthClientId,
    oAuthClientSecret,
    oAuthScopes,
    oAuthConfiguration,
  }:{
    oAuthClientId: string,
    oAuthClientSecret: string,
    oAuthScopes?: OAuthScopeEnum[],
    oAuthConfiguration?: OAuthConfiguration
  }, client: ClientInterface) {
    this._oAuthClientId = oAuthClientId;
    this._oAuthClientSecret = oAuthClientSecret;
    this._oAuthScopes = oAuthScopes;
    this._oAuthConfiguration = oAuthConfiguration;
    this._oAuthController = new OAuthAuthorizationController(client);
  }

  public async updateToken(oAuthToken?: OAuthToken): Promise<OAuthToken> {
    if (!this.isValid(oAuthToken) || this.isExpired(oAuthToken)) {
      oAuthToken = await this.fetchToken();
    }
    return oAuthToken;
  }

  public isValid(oAuthToken: OAuthToken | undefined): oAuthToken is OAuthToken {
    return typeof oAuthToken !== 'undefined';
  }

  public isExpired(oAuthToken: OAuthToken) {
    if (typeof oAuthToken.expiry === 'undefined') {
      return false; // Expiry is undefined, token cannot be expired
    }

    let tokenExpiry = oAuthToken.expiry;

    // Adjust expiration time if clockSkew is provided and is not undefined
    if (this._oAuthConfiguration &&
      typeof this._oAuthConfiguration.clockSkew !== 'undefined') {
      tokenExpiry -= BigInt(this._oAuthConfiguration.clockSkew); // Subtract clockSkew from expiry
    }

    return tokenExpiry < Date.now() / 1000;
  }

  public async fetchToken(
    additionalParams?: Record<string, unknown>
  ): Promise<OAuthToken> {
    const authorization = this.getClientBasicAuth(
      this._oAuthClientId,
      this._oAuthClientSecret
    );
    const { result } = await this._oAuthController.requestToken(
      authorization,
      this._oAuthScopes?.join(' '),
      additionalParams
    );
    return this.setExpiry(result);
  }

  private getClientBasicAuth(clientId: string, clientSecret: string): string {
    return `Basic ${Buffer.from(clientId + ':' + clientSecret,).toString(
      'base64'
    )}`;
  }

  private async setExpiry(token: OAuthToken) {
    const newToken = token
    if (newToken.expiresIn) {
      newToken.expiry = BigInt(Math.round(Date.now() / 1000)) + newToken.expiresIn;
    }
    return newToken;
  }
}
